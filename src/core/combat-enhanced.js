/**
 * Enhanced Combat System
 * 
 * Implements auto-attack + triggered skills, hit chance, crits, resist checks,
 * damage calculation, and threat generation.
 */

(function (global) {
  let autoAttackInterval = null;
  let skillCooldowns = new Map();
  let activeBuffs = new Map();
  let currentThreat = 0;

  /**
   * Calculate hit chance based on attacker and defender stats
   */
  function calculateHitChance(attackerLevel, defenderLevel, attackerDex, defenderAgi) {
    const levelDiff = attackerLevel - defenderLevel;
    const statDiff = attackerDex - defenderAgi;
    
    // Base hit chance
    let hitChance = 0.95; // 95% base
    
    // Level difference affects hit chance
    if (levelDiff < -5) hitChance -= 0.15; // -15% if 5+ levels below
    else if (levelDiff < -3) hitChance -= 0.10; // -10% if 3-4 levels below
    else if (levelDiff < 0) hitChance -= 0.05; // -5% if 1-2 levels below
    else if (levelDiff > 3) hitChance += 0.05; // +5% if 3+ levels above
    
    // Stat difference affects hit chance
    hitChance += (statDiff / 100) * 0.1; // Max 10% from stats
    
    return Math.max(0.05, Math.min(0.99, hitChance)); // Clamp between 5% and 99%
  }

  /**
   * Check if attack hits
   */
  function rollHit(attackerLevel, defenderLevel, attackerDex, defenderAgi) {
    const hitChance = calculateHitChance(attackerLevel, defenderLevel, attackerDex, defenderAgi);
    return Math.random() < hitChance;
  }

  /**
   * Calculate critical hit chance
   */
  function calculateCritChance(attackerLevel, defenderLevel, attackerDex) {
    let critChance = 0.05; // 5% base crit chance
    
    // Higher level = more crit chance
    const levelDiff = attackerLevel - defenderLevel;
    if (levelDiff > 0) {
      critChance += levelDiff * 0.01; // +1% per level above
    }
    
    // Dex affects crit chance
    critChance += (attackerDex / 100) * 0.05; // Max 5% from dex
    
    return Math.min(0.25, critChance); // Max 25% crit chance
  }

  /**
   * Check if attack crits
   */
  function rollCrit(attackerLevel, defenderLevel, attackerDex) {
    const critChance = calculateCritChance(attackerLevel, defenderLevel, attackerDex);
    return Math.random() < critChance;
  }

  /**
   * Calculate spell resist chance
   */
  function calculateResistChance(casterLevel, targetLevel, resistType, targetResist) {
    const levelDiff = casterLevel - targetLevel;
    let resistChance = 0.0;
    
    // Level difference affects resist
    if (levelDiff < -5) resistChance += 0.30; // +30% if 5+ levels below
    else if (levelDiff < -3) resistChance += 0.20; // +20% if 3-4 levels below
    else if (levelDiff < 0) resistChance += 0.10; // +10% if 1-2 levels below
    else if (levelDiff > 3) resistChance -= 0.10; // -10% if 3+ levels above
    
    // Target resist stat affects chance
    resistChance += (targetResist || 0) / 100 * 0.5; // Max 50% from resist stat
    
    return Math.max(0.0, Math.min(0.95, resistChance)); // Clamp between 0% and 95%
  }

  /**
   * Check if spell is resisted
   */
  function rollResist(casterLevel, targetLevel, resistType, targetResist) {
    const resistChance = calculateResistChance(casterLevel, targetLevel, resistType, targetResist);
    return Math.random() < resistChance;
  }

  /**
   * Calculate damage with variance
   */
  function calculateDamage(attackerAtk, defenderDef, isCrit = false) {
    let baseDamage = Math.max(1, attackerAtk - defenderDef);
    
    // Add variance (30% of base damage)
    const variance = Math.floor(baseDamage * 0.3);
    baseDamage += Math.floor(Math.random() * variance * 2) - variance;
    
    // Apply crit multiplier
    if (isCrit) {
      baseDamage = Math.floor(baseDamage * 1.5);
    }
    
    return Math.max(1, baseDamage);
  }

  /**
   * Calculate threat generated by an action
   */
  function calculateThreat(damage, threatMultiplier = 1.0, isHeal = false) {
    if (isHeal) {
      // Healing generates threat (50% of healing amount)
      return Math.floor(damage * 0.5 * threatMultiplier);
    }
    // Damage generates threat equal to damage * multiplier
    return Math.floor(damage * threatMultiplier);
  }

  /**
   * Use a skill in combat
   */
  function useSkill(skillId, target) {
    const player = global.State?.getPlayer();
    if (!player) return false;

    // Get skill data
    const skill = global.REALM?.data?.skillsById?.[skillId];
    if (!skill) return false;

    // Check if skill is learned
    if (!player.skills || !player.skills[skillId]) {
      global.ChatSystem?.addSystemMessage('You do not know that skill.');
      return false;
    }

    // Check level requirement
    if (player.level < skill.requiredLevel) {
      global.ChatSystem?.addSystemMessage('You are not high enough level to use that skill.');
      return false;
    }

    // Check cooldown
    const lastUsed = skillCooldowns.get(skillId);
    if (lastUsed && (Date.now() - lastUsed) < skill.cooldown * 1000) {
      const remaining = Math.ceil((skill.cooldown * 1000 - (Date.now() - lastUsed)) / 1000);
      global.ChatSystem?.addSystemMessage(`Skill on cooldown. ${remaining}s remaining.`);
      return false;
    }

    // Check resource cost
    const resourceType = skill.cost ? Object.keys(skill.cost)[0] : null;
    const resourceCost = skill.cost ? skill.cost[resourceType] : 0;
    
    // TODO: Check player resources (mana, rage, energy)
    // For now, allow all skills

    // Set cooldown
    skillCooldowns.set(skillId, Date.now());

    // Execute skill effect
    executeSkillEffect(skill, target);

    return true;
  }

  /**
   * Execute skill effect
   */
  function executeSkillEffect(skill, target) {
    const player = global.State?.getPlayer();
    if (!player || !target) return;

    const effect = skill.effect;
    const playerStats = global.Combat?.getPlayerStats();

    if (effect.type === 'damage') {
      // Calculate spell damage or ability damage
      let damage = 0;
      
      if (skill.type === 'spell') {
        // Spell damage based on INT
        damage = Math.floor((playerStats.int || 50) * parseFloat(effect.formula.split('*')[1] || 1));
        damage += effect.bonusDamage || 0;
        
        // Check for resist
        const resistType = effect.resistType || 'magic';
        if (rollResist(player.level, target.level, resistType, target.magicResist || 0)) {
          global.Narrative?.addEntry({
            type: 'combat',
            text: `${target.name} resists your ${skill.name}!`,
            meta: 'Resist'
          });
          return;
        }
      } else {
        // Ability damage based on ATK
        damage = Math.floor((playerStats.atk || 5) * parseFloat(effect.formula.split('*')[1] || 1));
        damage += effect.bonusDamage || 0;
        
        // Check hit chance
        if (!rollHit(player.level, target.level, playerStats.dex || 50, target.agi || 50)) {
          global.Narrative?.addEntry({
            type: 'combat',
            text: `Your ${skill.name} misses ${target.name}!`,
            meta: 'Miss'
          });
          return;
        }
      }
      
      // Apply damage
      target.stats.hp = Math.max(0, target.stats.hp - damage);
      
      // Generate threat
      const threatMultiplier = effect.threatMultiplier || 1.0;
      currentThreat += calculateThreat(damage, threatMultiplier);
      
      global.Narrative?.addEntry({
        type: 'combat',
        text: `You ${skill.name} ${target.name} for ${damage} damage!`,
        meta: `${target.name} HP: ${target.stats.hp}/${target.stats.maxHp}`
      });

      if (target.stats.hp <= 0) {
        // Target defeated
        global.Combat?.endCombat(true);
      }
    } else if (effect.type === 'heal') {
      // Healing
      const healing = Math.floor((playerStats.wis || 50) * parseFloat(effect.formula.split('*')[1] || 1));
      const bonusHealing = effect.bonusHealing || 0;
      const totalHealing = healing + bonusHealing;
      
      const newHp = Math.min(playerStats.maxHp, playerStats.hp + totalHealing);
      const actualHealing = newHp - playerStats.hp;
      
      global.State?.updatePlayer({
        stats: {
          ...playerStats,
          hp: newHp
        }
      });
      
      global.Narrative?.addEntry({
        type: 'combat',
        text: `You heal yourself for ${actualHealing} HP!`,
        meta: `Your HP: ${newHp}/${playerStats.maxHp}`
      });
      
      global.Rendering?.updateCharacterPanel();
    }
  }

  /**
   * Start auto-attack
   */
  function startAutoAttack(target) {
    if (autoAttackInterval) {
      clearInterval(autoAttackInterval);
    }

    // Auto-attack every 3 seconds
    autoAttackInterval = setInterval(() => {
      if (!target || !global.Combat?.isInCombat()) {
        stopAutoAttack();
        return;
      }

      global.Combat?.playerAttack();
    }, 3000);
  }

  /**
   * Stop auto-attack
   */
  function stopAutoAttack() {
    if (autoAttackInterval) {
      clearInterval(autoAttackInterval);
      autoAttackInterval = null;
    }
  }

  /**
   * Get current threat
   */
  function getThreat() {
    return currentThreat;
  }

  /**
   * Reset threat
   */
  function resetThreat() {
    currentThreat = 0;
  }

  /**
   * Clear all cooldowns (on combat end)
   */
  function clearCooldowns() {
    skillCooldowns.clear();
    activeBuffs.clear();
    resetThreat();
  }

  const CombatEnhanced = {
    calculateHitChance,
    rollHit,
    calculateCritChance,
    rollCrit,
    calculateResistChance,
    rollResist,
    calculateDamage,
    calculateThreat,
    useSkill,
    startAutoAttack,
    stopAutoAttack,
    getThreat,
    resetThreat,
    clearCooldowns
  };

  global.CombatEnhanced = CombatEnhanced;
})(window);

